<!DOCTYPE html>
<html>

<head>
	<title>Carbon4PUR CO2/CO sources and consumer map</title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta charset="utf-8">
	<!-- Load Leaflet: instructions at http://leafletjs.com/download.html -->
	<link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet" />
	<!-- A CSS framework for easy styling -->
	<link href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" rel="stylesheet" />
	<link href="index.css" rel="stylesheet">
	<script src="https://unpkg.com/leaflet/dist/leaflet.js">
	</script>
	<!-- Load Omnivore plugin to convert CSV to GeoJSON format -->
	<script src='https://unpkg.com/csv2geojson/csv2geojson.js'>
	</script>
	<!-- Load d3: only for size legend for now -->
	<script src="https://d3js.org/d3.v3.min.js">
	</script>
</head>

<body>
	<!-- Symbol definition -->
	<svg aria-hidden="true" style="position: absolute; width: 0; height: 0; overflow: hidden;" version="1.1" xmlns="http://www.w3.org/2000/svg">
		<defs>
			<symbol id="icon-folder-plus" viewbox="0 0 32 32">
				<title>folder-plus</title>
				<path d="M18 8l-4-4h-14v26h32v-22h-14zM22 22h-4v4h-4v-4h-4v-4h4v-4h4v4h4v4z"></path>
			</symbol>
			<symbol id="icon-folder-minus" viewbox="0 0 32 32">
				<title>folder-minus</title>
				<path d="M18 8l-4-4h-14v26h32v-22h-14zM22 22h-12v-4h12v4z"></path>
			</symbol>
			<symbol id="icon-play3" viewbox="0 0 32 32">
				<title>play3</title>
				<path d="M6 4l20 12-20 12z"></path>
			</symbol>
		</defs>
	</svg>
	<!-- Map takes whole screen -->

	<div id="map"></div>
	<!-- Size legend -->
	<div id="mapTitle">
		Carbon4PUR mapping of CO / CO<sub>2</sub>
	</div>
	<!-- Size legend -->
	<div id="scale">
		<h3>Emissions in Megatonnes</h3>
	</div>
	<!-- Legend and control -->
	<div id="layercontrol">
		<div id="layercontrolCont">
			<div id="layercontrolNoSub">
				<h3>Possible consumers</h3>
			</div>
			<div id="layercontrolSub">
				<h3>Emitters</h3>
			</div>
		</div><span data-minimized="false" id="layercontrolMinimize"><svg class="icon icon-play3">
		<use xlink:href="#icon-play3"></use></svg></span>
	</div>
	<script>

		/* Set up the map with initial center and zoom level */
		let map = L.map('map', {
			center: [51.65892, 6.41601], // EDIT latitude, longitude to re-center map
			zoom: 5, // EDIT from 1 to 18 -- decrease to zoom out, increase to zoom in
			scrollWheelZoom: false
		});
		/* Carto light-gray basemap tiles with labels */
		let light = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png', {
				attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap<\/a>, &copy; <a href="https://carto.com/attribution">CARTO<\/a>, <a href="http://prtr.ec.europa.eu">E-PRTR</a>'
			})
			.addTo(map);

		let dataModel = {
			totalMax: 0,
			emitters: [],
			consumers: [],
			allLayers: {}
		};

		/* Load all csv data files and create menu*/
		Promise.all([
				getEmissionData('CO', 'CO', 'CO.csv', "#004e83"),
				getEmissionData('CO2', 'CO<sub>2</sub>', 'CO2.csv', "#008D4D")
			]).then(loadedData => doStats(loadedData))
			.then(() => addEmissionsToMap())
			.then(() => addEmissionsToMenu())
			.then(() => getChemparkData('Chemical parks', 'chemicalparks.csv', "#CC7300"));

		function getEmissionData(emName, emDisplayName, file, color) {
			return new Promise((resolve, reject) => {
				fetch(file)
					.then(function(response) {
						return response.text();
					})
					.then(myBlob => convertCSV(myBlob))
					.then(geojson => resolve({
						emName: emName,
					        emDisplayName: emDisplayName,
						color: color,
						geojson: geojson
					}));
			});
		};

		function doStats(loadedData) {
			return new Promise((resolve, reject) => {
				for (var i = 0; i < loadedData.length; i++) {
					var max = Math.max.apply(Math, loadedData[i].geojson.features.map(function(o) {
						return o.properties.MTonnes;
					}));
					dataModel.totalMax = Math.max(dataModel.totalMax, max);
					dataModel.emitters.push(loadedData[i]);
					/*var min = Math.min.apply(Math, resultObj[i].geojson.features.map(function(o) {
					return o.properties.MTonnes;
					}));
					dataModel.totalMin = Math.min(dataModel.totalMin, min);*/
				}
				createScale();
				resolve(loadedData);
			});
		}

		function createScale() {
			var svg = d3.select('#scale').append('svg').attr('width', 185).attr('height', 120);
			svg = svg.append('g').attr('transform', 'translate(0,5)');
			var scale = d3.scale.sqrt().domain([0, dataModel.totalMax]).range([0, 50]);
			var formatSI = d3.format('.1f');
			var formatCurrencySI = function(d) {
				return formatSI(d) + ' MT'
			}
			var circleKey = circleLegend()
				.scale(scale)
				.tickValues([dataModel.totalMax / 100, dataModel.totalMax / 10, dataModel.totalMax])
				.tickFormat(formatCurrencySI)
				.tickPadding(10)
				.orient("left"); //default
			svg.append('g')
				.attr('transform', 'translate(116, 100)')
				.call(circleKey);
		}

		function getChemparkData(name, file, color) {
			fetch(file)
				.then(response => response.text())
				.then(myBlob => convertCSV(myBlob))
				.then(geojson => addParksToMap(geojson, color))
				.then(dataLayer => addParksToMenu(dataLayer, name));
		};

		function convertCSV(myBlob) {
			return new Promise((resolve, reject) => {
				csv2geojson.csv2geojson(myBlob, {
					latfield: 'latitude',
					lonfield: 'longitude',
					delimiter: ';',
				}, (err, geojson) => {
					if (err) {
						console.error(err);
						reject(err);
					} else {
						resolve(geojson);
					}
				});
			});
		};

		function addParksToMap(geojson, color) {
			return new Promise((resolve, reject) => {
				var dataLayer;
				fetch("potentials.json")
					.then(response => response.json())
					.then(potentials => {
						dataLayer = L.geoJSON(geojson, {
							pointToLayer: function(feature, latlon) {
								// L.circleMarker() draws a circle with fixed radius in pixels.
								return L.circleMarker(latlon, {
									color: color,
									weight: 0,
									radius: getChemParkSize(potentials, feature)
								});
							},
							onEachFeature: function(feature, layer) {
								layer.bindPopup(addPopupHandler(feature, potentials));
							}
						});
						resolve(dataLayer);
					});
			});
		};

		function getChemParkSize(potentials, feature){
			let size = Math.sqrt(potentials[feature.properties.FacilityName]["10000"]["CO2"] / dataModel.totalMax) * 50;
			if (size > 0){
				return size;
			}
			else {
				return 3;
			}
		}

		function addPopupHandler(feature, potentials){
			return function(){
				var htmlstring = '<h3>' + feature.properties.FacilityName + '</h3><table class="popupTable"><tr><th></th><th colspan="5">Potential of regulated emissions in a radius of:</th></tr><tr><th></th><th>500m</th><th>1km</th><th>5km</th><th>10km</th><th>50km</th></tr><tr>';
				for (em in potentials[feature.properties.FacilityName]["50000"]){
					let emName = em;
					if(em == "CO2") emName = "CO<sub>2</sub>";
					htmlstring += "<td>"+emName+"</td>";
					for (dist in potentials[feature.properties.FacilityName]){
						if(potentials[feature.properties.FacilityName][dist][em]){
							//console.log(potentials[feature.properties.FacilityName], dist, potentials[feature.properties.FacilityName][dist], em);
							htmlstring += "<td>" + potentials[feature.properties.FacilityName][dist][em].toFixed(2) + ' MT</td>';
						}
						else { htmlstring += "<td></td>";}
					}
					htmlstring += "</tr><tr>";
				}
				htmlstring = htmlstring.slice(0, -4);
				return htmlstring;
			}
		};

		function addParksToMenu(dataLayer, name) {
			let escName = name.replace(" ", "_");
			let layercontrolNoSub = d3.select('div#layercontrolNoSub');
			let label = layercontrolNoSub.append('label');
			let input = label.append('input');
			input.attr("type","checkbox")
				.attr("class", escName)
				.attr("id", escName + 'checkbAll');
			label.append("div").attr("style","display:inline;").text(name);
			layercontrolNoSub.append("br");
			input.on('change', function() {
					if (input.property("checked")) {
						map.addLayer(dataLayer);
					} else {
						map.removeLayer(dataLayer);
					}
				});
		}

		function addEmissionsToMap() {
			return new Promise((resolve, reject) => {
				var length = dataModel.emitters.length;
				for (var i = 0; i < length; i++) {
					var geojson = dataModel.emitters[i].geojson,
							emDisplayName= dataModel.emitters[i].emDisplayName,
							color= dataModel.emitters[i].color;
					var layers = {};
					var dataLayer = L.geoJSON(geojson, {
						pointToLayer: function(feature, latlon) {
							// L.circleMarker() draws a circle with fixed radius in pixels.
							return L.circleMarker(latlon, {
								color: color,
								weight: 0,
								radius: (Math.sqrt(feature.properties.MTonnes / dataModel.totalMax) * 50)
							});
						},
						onEachFeature: function(feature, layer) {
							feature.properties.NACEMainEconomicActivityName = feature.properties.NACEMainEconomicActivityName.replace("'", "&#39;");
							if (layers[feature.properties.NACEMainEconomicActivityName] == undefined) {
								layers[feature.properties.NACEMainEconomicActivityName] = {
									layer: new L.LayerGroup(),
									total: 0,
									count: 0
								};
							}
							layers[feature.properties.NACEMainEconomicActivityName].layer.addLayer(layer);
							layers[feature.properties.NACEMainEconomicActivityName].total += parseFloat(feature.properties.MTonnes);
							layers[feature.properties.NACEMainEconomicActivityName].count += 1;
							layer.bindPopup('<h3>' + feature.properties.FacilityName + '</h3><i>' + feature.properties.NACEMainEconomicActivityName + '</i><br />' + feature.properties.MTonnes + ' Mt ' + emDisplayName);
						}
					});
					dataModel.emitters[i]["layers"] = layers;
				}
				resolve();
			});
		}


		function addEmissionsToMenu() {
			return new Promise((resolve, reject) => {
				for (var i = 0; i < dataModel.emitters.length; i++) {
					let layers = dataModel.emitters[i].layers;
					let emName = dataModel.emitters[i].emName;
					let emDisplayName = dataModel.emitters[i].emDisplayName;
					let layercontrolSub = document.getElementById('layercontrolSub')
					layercontrolSub.appendChild(createMasterCheckbox(emName, emDisplayName, layers));
					layercontrolSub.appendChild(createCheckboxList(layers, emName, emDisplayName));
				}
				resolve();
			});
		}

		function toggleSingleCheckbox(e){
			for(let i=0;i<dataModel.emitters.length; i++){
				if(dataModel.emitters[i].emName === e.target.className){
					toggleLayer(dataModel.emitters[i].layers[e.target.dataset.layer.replace("'", "&#39;")].layer, e.target.checked);
				}
			}
		}
		function toggleLayer(layer, visible){
			if (visible) {
				map.addLayer(layer);
			}
			else {
				map.removeLayer(layer);
			}
		}

		function toggleMasterCheckbox(checkbox, group, layers){
			return function(){
				let boxes = document.getElementById(group).getElementsByTagName('input');
				for(var i = 0; i < boxes.length; ++i){
					boxes[i].checked = checkbox.checked;
				}
				for(var i=0;i<dataModel.emitters.length; i++){
					if(group.split("-")[1] === dataModel.emitters[i].emName){
						console.log(dataModel.emitters[i]);
						for(j in dataModel.emitters[i].layers){
							toggleLayer(dataModel.emitters[i].layers[j].layer, checkbox.checked);
						}
					}
				}
			}
		}
		function toggleCheckboxList(svg, group){
			return function(){
				let div = document.getElementById(group);
				div.style.display = div.style.display == "none" ? "inline-block" : "none";
				svg.classList.toggle("icon-folder-plus");
				let isMinus = svg.classList.toggle("icon-folder-minus");
				let use = svg.getElementsByTagName("use")[0];
				use.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', isMinus ? '#icon-folder-minus' : '#icon-folder-plus');
			}
		}

		function createMasterCheckbox(emName, emDisplayName, layers){
			let groupDiv = document.createElement("div");
			let label = document.createElement("label");
			let inputBox = document.createElement("input");
			inputBox.type="checkbox";
			inputBox.addEventListener("change", toggleMasterCheckbox(inputBox, 'layercontrolSub-' + emName, layers));
			label.appendChild(inputBox);
			label.insertAdjacentHTML('beforeend',emDisplayName);
			let svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
			svg.setAttribute('class', "icon icon-folder-plus");
			svg.style= "vertical-align:middle;";
			svg.addEventListener("click", toggleCheckboxList(svg, 'layercontrolSub-' + emName));
			let useElem = document.createElementNS('http://www.w3.org/2000/svg', 'use');
			useElem.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', '#icon-folder-plus');
			svg.appendChild(useElem);
			let textLegend = document.createTextNode(" (select by industry)");
			groupDiv.appendChild(label);
			groupDiv.appendChild(document.createElement("br"));
			groupDiv.appendChild(svg);
			groupDiv.appendChild(textLegend);
			groupDiv.appendChild(document.createElement("br"));
			return groupDiv;
		}

		function createCheckboxList(layers, emName, emDisplayName){
			let groupDiv = document.createElement("div");
			groupDiv.id='layercontrolSub-' + emName;
			groupDiv.style.display = "none";
			var i = 1;
			var keysSorted = Object.keys(layers).sort((a, b) => {
				return layers[b].total - layers[a].total
			});
			for (var layerName in keysSorted) {
				let name = keysSorted[layerName];
				let label = document.createElement("label");
				let inputBox = document.createElement("input");
				inputBox.dataset.layer = name;
				inputBox.type = "checkbox";
				inputBox.setAttribute('class', emName);
				inputBox.addEventListener("change", toggleSingleCheckbox);
				label.appendChild(inputBox);
				label.insertAdjacentHTML('beforeend', keysSorted[layerName] + ' (' + layers[keysSorted[layerName]].total.toFixed(2) + '&nbsp;Mt, ' + layers[keysSorted[layerName]].count + ')');
				label.appendChild(document.createElement("br"));
				groupDiv.appendChild(label);
				i = i + 1;
			}
			return groupDiv;
		}

		map.on('focus', () => {
			map.scrollWheelZoom.enable();
		});
		map.on('blur', () => {
			map.scrollWheelZoom.disable();
		});

		/*document.getElementById('mapTitle').addEventListener('mouseover', function() {
			document.getElementById('hiddenPartners').css("display", "inline");
		}).on('mouseout', function() {
			document.getElementById('hiddenPartners').css("display", "none");
		});
		setTimeout(function() {
			document.getElementById('hiddenPartners').hide(500);
		    }, 3000);

		document.getElementById('layercontrolMinimize').addEventListener('click', function() {
			if ($(this).data("minimized")) {
				$(this).data("minimized", false);
				$('#layercontrol').css('width', "250px");
				$("svg", this).css('transform', "rotate(0deg)");
			} else {
				$(this).data("minimized", true);
				$('#layercontrol').css('width', "20px");
				$("svg", this).css('transform', "rotate(180deg)");
			}
		});*/

		// Adapted from https://github.com/mbostock/d3/blob/master/src/svg/axis.js
		// forked from http://bl.ocks.org/aubergene/4723857
		var circleLegend = function circleLegend() {
			'use strict';

			var scale,
				orient = 'left',
				tickPadding = 3,
				tickExtend = 5,
				tickArguments_ = [10],
				tickValues = null,
				tickFormat_,
				ε = 1e-6;


			function key(selection) {
				selection.each(function() {
					var g = d3.select(this);

					g.attr('class', 'circle-legend');

					// Stash a snapshot of the new scale, and retrieve the old snapshot.
					var scale0 = this.__chart__ || scale,
						scale1 = this.__chart__ = scale.copy();

					// Ticks, or domain values for ordinal scales.
					var ticks = tickValues == null ? (scale.ticks ? scale.ticks.apply(scale, tickArguments_) : scale.domain()) : tickValues,
						ticks = ticks.slice().filter(function(d) {
							return d > 0
						}).sort(d3.descending),
						tickFormat = tickFormat_ == null ? (scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments_) : String) : tickFormat_,
						tick = g.selectAll('.tick').data(ticks, scale1),
						tickEnter = tick.enter().insert('g', '.tick').attr('class', 'tick').style('opacity', ε),
						tickExit = d3.transition(tick.exit()).style('opacity', ε).remove(),
						tickUpdate = d3.transition(tick.order()).style('opacity', 1),
						tickTransform;

					tickEnter.each(function(tick) {
						var gg = d3.select(this);

						var tickText = tickFormat(tick);

						if (!tickText) return;

						gg.append('circle')
							.attr('cx', 0)
							.attr('cy', 0)
							.attr('r', scale(tick));

						gg.append('line')
							.attr('y1', 0)
							.attr('y2', 0)
							.attr('stroke', '#000')
							.text(tick);

						gg.append('text')
							.attr('dy', '.35em')
							.style('text-anchor', 'left' == orient ? 'end' : 'start')
							.text(tickText);

					});
					tickEnter.call(d3_svg_legend, scale0);
					tickUpdate.call(d3_svg_legend, scale1);
					tickExit.call(d3_svg_legend, scale1);

					function d3_svg_legend(selection, scale) {
						selection.select('circle')
							.attr('r', scale);

						var x2 = scale(ticks[0]) + tickExtend;
						var sign = 'left' == orient ? -1 : 1;

						selection.select('text')
							.attr('transform', 'translate(' + (x2 + tickPadding) * sign + ', 0)');

						selection.select('line')
							.attr('x1', function(d) {
								return scale(d) * sign
							})
							.attr('x2', x2 * sign);

						selection.attr('transform', function(d) {
							return 'translate(0,' + -scale(d) + ')';
						});
					}

				});
			}

			key.scale = function(value) {
				if (!arguments.length) return scale;
				scale = value;
				return key;
			};

			key.orient = function(value) {
				if (!arguments.length) return orient;
				orient = value;
				return key;
			};

			key.ticks = function() {
				if (!arguments.length) return tickArguments_;
				tickArguments_ = arguments;
				return key;
			};

			key.tickFormat = function(x) {
				if (!arguments.length) return tickFormat_;
				tickFormat_ = x;
				return key;
			};

			key.tickValues = function(x) {
				if (!arguments.length) return tickValues;
				tickValues = x;
				return key;
			};

			key.tickPadding = function(x) {
				if (!arguments.length) return tickPadding;
				tickPadding = +x;
				return key;
			};

			key.tickExtend = function(x) {
				if (!arguments.length) return tickExtend;
				tickExtend = +x;
				return key;
			};

			key.width = function(value) {
				if (!arguments.length) return width;
				width = value;
				return key;
			};

			key.height = function(value) {
				if (!arguments.length) return height;
				height = value;
				return key;
			};

			return key;
		};
	</script>
</body>

</html>
